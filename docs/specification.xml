<?xml-stylesheet href="specstyle.css"?>
<specification>
    <group name="Setup">
        <requirement>
            <design>Users must be able to easily import the library and add it into their code.</design>
            <implementation>Supports html script tag, or simply just require('shimi'). Second option gives full intellisense support</implementation>
        </requirement>

        <requirement>
            <design>Users must be able to get MIDI access which they can use to connect to any available MIDI port by name.</design>
            <implementation>The MidiAccess class exposes a static async request() method which calls the requestMIDIAccess browser function. It returns a new instance of the MidiAccess class. The MidiAccess class has methods getInPort and getOutPort, both of which take the port name as parameter.</implementation>
        </requirement>
    </group>

    <group name="Midi Out">
        <requirement>
            <design>Users must be able to create a MIDI output which references a MIDI port. This MIDI output must expose functions for all of the Channel Voice Messages as defined in the MIDI 1.0 specification (https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message), each of which send the corresponding MIDI message to the connected port.</design>
            <implementation>The MidiOut class includes methods for sending each of the Channel Voice messages as defined in the MIDI specification. Since the Pitch Bend Change message is very unfriendly to work with due to the bend value being split over 2 bytes, the sendPitchBend method takes a percent parameter which ranges from -1 to +1, which gets converted into the 2 byte bend value. The MidiOut class also has a sendRawData method which takes an array of data to be sent to the MIDI port as is.</implementation>
        </requirement>

        <requirement>
            <design>Users must be able to pass note objects to a MIDI output, where the MIDI output will send a Note On message as soon as the note object is added, it will then track the note and automatically send a Note Off message as soon as the note object's state gets updated to say it needs to stop.</design>
            <implementation>The MidiOut class has an addNote method which takes a note object. It then stores that object. It also implements the IClockChild interface, with an update method that checks if any of the note objects have had their 'on' property changed to false since the previous update.</implementation>
        </requirement>

        <requirement>
            <design>Users must be able to create an object which sends regular update messages to Midi outputs, metronomes, or any other object which requires frequent updates.</design>
            <implementation>Added the Clock object which takes in as a constructor parameter how many milliseconds should be between each update. Has start and stop methods for controlling the running of the clock, as well as a list of children that it should update.</implementation>
        </requirement>

        <requirement>
            <design>Note objects added to the MIDI out must immediately have their note on messages sent, then subsequent note pressure &amp; note off messages must be sent from the update loop.</design>
            <implementation>MidiOut.addNote method sends note on message if the note has its 'on' property set to true.</implementation>
        </requirement>
    </group>

    <group name="Input Devices">
        <requirement>
            <design>Users must have an easy way to attach logic to key presses and releases on their computer keyboard. There must be a more readable + consistent mechanism available to them than adding an event listener and comparing event key codes.</design>
            <implementation>The Keyboard class manages all key state tracking. The user can then just add logic like: keyboard.q.pressed.add(() => ...);</implementation>
        </requirement>

        <requirement>
            <design>Users must have a way to be able to search through all keys on their keyboard. Each key should be able to easily tell them if it's currently pressed, and if so, how long it's been pressed for.</design>
            <implementation>The Keyboard class has a buttons array, which contains all of the ButtonInput objects that it also holds as properties. So you can do stuff like keyboard.buttons.filter(b => b.activeMs > 500)</implementation>
        </requirement>

        <requirement>
            <design>Users must have an easy way to attach logic to events on one or more connected game controllers.</design>
            <implementation>Each gamepad uses a ButtonInput or SliderInput for each input it has so that functionality can be easily added to them. Each gamepad gets added to a Gamepads class which handles the logic of updating button states and matching gamepad objects to incoming gamepad data.</implementation>
        </requirement>

        <requirement>
            <design>Users must have a way to be able to search through all game controllers, and all inputs on each game controller. Each input should be able to easily tell them what its current state is, also how long its been active for.</design>
            <implementation>The Gamepads class has an activeGamepads property that returns all gamepads currently able to receive incoming data. Each gamepad has buttons &amp; axes properties for getting the inputs on it.</implementation>
        </requirement>

        <requirement>
            <design>Users must be able to toggle if actions are on or off. An off action will be ignored by the input event it's attached to.</design>
            <implementation>ShimiHandler has on property, which if false, prevents the handler's logic from being called</implementation>
        </requirement>

        <requirement>
            <design>Users must be able to identify actions by reference so they can modify them later if needed.</design>
            <implementation>ShimiHandler has optional ref string property for identification purposes</implementation>
        </requirement>
    </group>

    <group name="Metronome">
        <requirement>
            <design>Users should be able to create metronomes which don't just count how many quarter notes have passed in a bar, but can also divide a bar into a set of more abstract 'beats'. Where each beat can be of different length to the others. For example, the beat structure of a metronome for the Mission Impossible theme may count 4 beats per bar, despite the theme being in 5/4, where beats 1 + 2 are a dotted quarter note each, while beats 3 + 4 are a quarter note each.</design>
            <implementation>The TimeSig class takes an array of 'divisions', where each division is one beat of the bar, defining its own count and optional swing. The Flexinome class implements the IMetronome interface much like the regular Metronome class but its implementation takes full advantage of the TimeSig's divisions.</implementation>
        </requirement>

        <requirement>
            <design>Metronomes should be able to apply swing. This swing can be either universal, or customly set per beat. This would for example, allow fine tune control of how a 4-beat pattern in 4/4 gets played on a 4-beat 11/8 metronome.</design>
            <implementation>The fine-grain, per-beat control of swing is only available to the Flexinome. If a TimeSig defines a swing value on one of its divisions, then that swing value will be taken over whatever overall swing value the TimeSig has.</implementation>
        </requirement>

        <requirement>
            <design>Users mustn't be tied to the more abstract irregular-beat driven metronome approach. If they want to use a simple metronome that just counts 1 quarter-note = 1 beat, they must also be able to do that.</design>
            <implementation>Added Metronome class which implements the IMetronome interface. The interface allows for both quarterNote &amp; beat properties to be exposed, though in this case the they both essentially just tracker quarter notes, with minor difference being that the beat property will also expose any swing.</implementation>
        </requirement>

        <requirement>
            <design>If using the more standard, rudimentary form of metronome, then swing can only be applied universally, not differently across various parts of the bar. Also, if the metronome is counting a rhythm with a non-integer number of quarter-notes per bar, then no swing will be applied to the final fractional beat part of the bar.</design>
            <implementation>The simple Metronome class just uses TimeSig's swing property for determining its swing, it doesn't use swing defined at the division level. If it's at the end of a bar where the last quarter note is incomplete, then it ignores any swing for that little bit only.</implementation>
        </requirement>
    </group>

    <group name="Clips">
        <requirement>
            <design>Users must be able to create Clip objects, where a clip has a pre-defined beat count, and specifies a number of notes to be played at specific times, each with their own velocities.</design>
            <implementation>The Clip class extends the Range class which specifies the duration. Clip contains an array of ClipNotes, where each one defines the start, duration, pitch, velocity &amp; optionally channel of a note to be played.</implementation>
        </requirement>

        <requirement>
            <design>Clips must be able to support information for control changes and pitch bends, whether that be a single value, or some set of calculated/recorded values that morph over time.</design>
            <implementation>Clips have ClipCCs &amp; ClipBends. The ClipCC value &amp; ClipBend percent properties can take either a simple value, or a function which takes a parameter of how far through the CC/bend automation we currently are.</implementation>
        </requirement>

        <requirement>
            <design>Users must be able to create clip player objects, which define a clip that's to be played, which metronome to base the clip's timing on, what speed to play it at, what channel to play it on, how to modify the pitch of each note, and how to modify the velocity of each note.</design>
            <implementation>The ClipPlayer class has clip, channel, metronome, speed, startBeat, beatCount &amp; noteModifier properties. Where noteModifier gets called for each new note that's created by the player.</implementation>
        </requirement>

        <requirement>
            <design>Users must be able to pass a clip player into a Midi Output to have the clip it contains be played.</design>
            <implementation>ClipPlayer implements the IMidiOutChild interface. IMidiOut contains addProcess &amp; stopProcesses methods. When a ClipPlayer instance is added to the MidiOut, it will receive update messages from the MidiOut, which it will use to add notes, send messages etc through the MidiOut.</implementation>
        </requirement>

        <requirement>
            <design>Users must be able to duplicate clips.</design>
        </requirement>

        <requirement>
            <design>Users must be able to quantize the events of a clip to some desired level of precision.</design>
        </requirement>
    </group>

    <group name="Scales">
        <requirement>
            <design>Have templates for the common scale types (major, natural minor, melodic minor, dorian, phrygian, etc.) which specify the intervals that make up any specific scale of that type. Allow users to also create their own custom scale templates.</design>
            <implementation>ScaleTemplate class stores name, shape (array of intervals) &amp; relativityToMajor. It has static getters on it for retrieving instances of the common scale types.</implementation>
        </requirement>

        <requirement>
            <design>Allow users to create a scale with a specific root pitch from one of these scale templates.</design>
            <implementation>ScaleTemplate class has create() function which takes in a root and uses that to build a new scale</implementation>
        </requirement>

        <requirement>
            <design>Each scale should allow users to find out if a given pitch is in or out of scale, and what scale degree it is.</design>
            <implementation>Scale class has contains() function which returns whether the scale contains a passed in pitch. It also has indexOf() function which returns the 0-based index of the pitch within the scale, or -1 if it's not contained.</implementation>
        </requirement>

        <requirement>
            <design>For any pitch, regardless of whether it's in or out of the scale, the scale object should be able to tell you how to express it, eg. F# or Gb.</design>
            <implementation>Added getPitchName function to Scale class, which uses a cache of pre-calculated names based on the scale's relative major.</implementation>
        </requirement>

        <requirement>
            <design>Each scale should allow you to get related scales, specifically dominant, subdominant, relative (with scale template) and parallel (with scale template).</design>
            <implementation>Added getDominantScale(), getSubdominantScale(), getRelativeScale(template) &amp; getParallelScale(template) methods to Scale class.</implementation>
        </requirement>

        <requirement>
            <design>A scale must be able to move a pitch up/down to the nearest pitch which is in it, or at least doesnt clash with it.</design>
            <implementation>Added fitPitch function to Scale class which takes in a pitch, and attempts to move it to the nearest note in the scale.</implementation>
        </requirement>
    </group>

    <group name="Chords">
        <requirement>
            <design>Users must be able to create a chord object which they can set the pitch and add or remove pitches to.</design>
            <implementation>Chord class has addPitch, addPitches, removePitches &amp; setRoot methods.</implementation>
        </requirement>

        <requirement>
            <design>Chord must have a way of calculating a good estimate of what its name is.</design>
        </requirement>

        <requirement>
            <design>A chord must be able to tell you whether a given pitch is in or out of it.</design>
            <implementation>Chord implements IPitchContainer interface, which includes contains method.</implementation>
        </requirement>

        <requirement>
            <design>A chord must be able to move a pitch up/down to the nearest pitch which is in it, or at least doesnt clash with it.</design>
            <implementation>Chord implements IPitchContainer interface, which includes fitPitch method.</implementation>
        </requirement>

        <requirement>
            <design>Users must have a way of calculating the note that best fits to the chord. They must be able to choose between exact fitting and close fitting, where the scale is also taken into account in considering what would be the best fit.</design>
        </requirement>

        <requirement>
            <design>There must be a way of passing in some pitches, optionally a scale, and some allowable chord shapes, which then get used to return chord recommendations.</design>
        </requirement>
    </group>

    <requirement>
        <design>Users must be able to create Cue objects, which specify an action, as well as a metronome + beat delay, a millisecond delay, or a condition which determines when the action gets run.</design>
        <implementation>Added ConditionalCue for cuing something up when a certain condition is met, MsCue for cuing something up after a set number of milliseconds &amp; BeatCue for cuing something up after a certain number of beats have passed on a linked metronome. Added Cue.when(condition, action), Cue.afterMs(msCount, action) &amp; Cue.afterBeats(metronome, beatCount, action) for easy creation of these objects.</implementation>
    </requirement>

    <group name="Midi Inputs">
        <requirement>
            <design>Users must be able to receive messages from a MIDI input which they can use as triggers for other actions within the program.</design>
            <implementation>MidiIn class takes a MIDI port as constructor parameter which it automatically subscribes to. Its receiveData method interprets incoming data to see what kind of message is being received and triggers the appropriate event.</implementation>
        </requirement>

        <requirement>
            <design>Messages from midi inputs must be easily duplicatable to allow for easily forwarding messages to an output with slight modifications.</design>
            <implementation>All the midi message classes now implement from a common IMidiMessage interface which defines a duplicate() method. Each of the individual messages have their own implementations of this method to create a copy of themselves.</implementation>
        </requirement>
    </group>

    <group name="Clip Recorder">
        <requirement>
            <design>Users must be able to create a clip recorder, which receives MIDI messages and uses them to build up a clip of pre-defined length.</design>
            <implementation>Users can create a ClipRecorder object which they add to the clock. This has a defined beat count and listens for messages from a MidiIn.</implementation>
        </requirement>

        <requirement>
            <design>The recorder must have a way of alerting the rest of the program the moment that the new clip is finished so it can be handled without delay.</design>
            <implementation>Once the recorder has finished, it dispatches a newClip event which can be subscribed to.</implementation>
        </requirement>
    </group>

    <group name="Midi Bus">
        <requirement>
            <design>Users must be able to create a Midi Bus, which allows you to send data to it like a MidiOut, and also receive data from it like a MidiIn</design>
            <implementation>MidiBus class implements IMidiOut for allowing midi messages &amp; notes to be sent to it. It also implements IMidiOut for allowing midi messages to be broadcast to the rest of the application.</implementation>
        </requirement>

        <requirement>
            <design>When you send data to a Midi Bus, it should immediately send it out again.</design>
            <implementation>MidiBus's receiveData, sendMessage &amp; sendRawData methods all instantly trigger the firing of one of MidiBus's midi events that can be subscribed to. When you add a note to MidiBus, its message will be triggered on the next update cycle, just like in MidiOut.</implementation>
        </requirement>

        <requirement>
            <design>When you send notes to a Midi Bus, it should output the exact events that a regular Midi Out would.</design>
            <implementation>MidiBus doesn't share the note object with downstream processes. Instead it broadcasts NoteOn, NoteOff &amp; NotePressure messages, just like a MidiOut object sends to its port.</implementation>
        </requirement>
    </group>
</specification>